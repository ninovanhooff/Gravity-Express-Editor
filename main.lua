---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ninovanhooff.
--- DateTime: 13/05/2022 16:58
---

local bit32 = require("bit")
local unpack = love.data.unpack
local max = math.max

local units_in_block = 8

function inspect(tbl)
    for i,item in pairs(tbl) do
        print(i,item)
    end
end

function table.sum(tbl)
    local sum = 0
    for i,item in pairs(tbl) do
        sum = sum + item
    end
    return sum
end

function love.conf(t)
    t.console = true
end

function love.draw()
    local quad
    for x, xtem in ipairs(brickT) do
        for y, ytem in ipairs(xtem) do
            if ytem[1] ~= 0 then
                -- todo creating quads has terrible performance
                quad = love.graphics.newQuad((ytem[1]-3)*64, 0, 8, 8, sprite:getWidth(), sprite:getHeight())
                love.graphics.draw(sprite, quad, x*8-8, y*8-8)
            end

        end
    end
end

local function assertHeader(self, name)
    print(name)
    local magicOrHeader = self:read(4)
    if(magicOrHeader == name) then return end
    assert(self:read(4) == name)
end

local function readInt(self, amount, bytesPerInt)
    result = {}
    if amount < 1 then
        return result
    end
    for i = 1,amount do
        result[i] = unpack("<I"..bytesPerInt, self:read(bytesPerInt))
    end
    return result
end

-- split a byte into first and second unsigned 4-bit numbers
local function splitByte(byte)
   return {
       bit32.rshift(byte, 4),
       bit32.band(byte, 15) -- mask lowest 4 bits
   }
end

--- parameters in CG units (1 unit = 4px)
local function geBrickType(cgGfxX, cgGfxY)
    if cgGfxX< 0 or cgGfxY<0 or cgGfxX > 108 or cgGfxY > 15 then
        print(cgGfxX, cgGfxY)
        error("outside brick range")
    end
    if cgGfxX < 15 then
        return 3 -- red a.k.a. brown
    elseif cgGfxX < 30 then
        return 4 -- yellow
    elseif cgGfxX < 45 then
        return 5 -- blue
    elseif cgGfxX < 60 then
        return 6 -- green
    else
        return 7 -- concrete
    end
end

local function createBrickT(cgSizeInBlocks, sobs)
    -- cg blocks are 32x32 pixels, eg tiles are 8x8. So, multiply by 4 to get the same dimensions
    local geSizeX = max(cgSizeInBlocks[1] *4)
    local geSizeY = max(cgSizeInBlocks[2] *4)
    local brickT = {}
    local floor = math.floor

    -- initialize empty brickT
    for x = 1, geSizeX do
        brickT[x] = {}
        for y = 1, geSizeY do
            brickT[x][y] = {0,1,1,0,0} -- type,w,h,subx,suby
        end
    end

    print("brickT dim", #brickT, #brickT[1])


    local curBrick
    for _,sob in ipairs(sobs) do
        curBrick = brickT[floor(sob[1]/2) + 1][floor(sob[2]/2) + 1]
        curBrick[1] = geBrickType(sob[5], sob[6])
        -- todo: if concrete, set other brickT params
    end

    return brickT
end

function love.load()
    brickT = {}
    sprite = love.graphics.newImage("sprite.png")


    --local fp = io.open("nino1.cgl", "rb")
    local fp = io.open("level01.cgl", "rb")

    print("file", fp, type(fp))

    -- file header
    assertHeader(fp, "CGL1")

    assertHeader(fp, "SIZE")
    local size = readInt(fp, 2, 4)
    inspect(size)

    assertHeader(fp, "SOIN")
    local soin = readInt(fp, size[1]*size[2], 1)
    for i,item in ipairs(soin) do
        soin[i] = bit32.band(item, 127) -- ignore most significant bit
    end
    numSobs = table.sum(soin)

    assertHeader(fp, "SOBS")
    local sobs = {}

    local x,y = 1,1
    local blockOffX = 0
    local blockOffY = 0
    local tile, posInBlock, tileDim
    for i = 1, #soin do
        blockOffX = (x-1) * units_in_block
        blockOffY = (y-1) * units_in_block
        for _ = 1, soin[i] do
            tile = readInt(fp, 4, 1)
            posInBlock = splitByte(tile[1])
            tileDim = splitByte(tile[2])

            table.insert(sobs, {
                blockOffX+posInBlock[1],
                blockOffY+posInBlock[2],
                tileDim[1],
                tileDim[2],
                tile[4], -- gfx x. In the level, they are swapped
                tile[3] -- gfx y
            })
        end
        x = x + 1
        if x > size[1] then
            -- go to next row
            x = 1
            y = y + 1
        end
    end

    print("numsobs", numSobs, #sobs)
    inspect(sobs[1])
    brickT = createBrickT(size, sobs)
    love.window.setMode( size[1]*32,size[2]*32 )


    assertHeader(fp, "VENT")
    local numFans = readInt(fp, 1, 4)[1]
    print("numFans", numFans)
    readInt(fp, numFans * 38, 1)
    assertHeader(fp, "MAGN")

    --love.event.quit()

end
