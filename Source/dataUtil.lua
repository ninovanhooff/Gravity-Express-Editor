--- Saving and loading of level files
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ninovanhooff.
--- DateTime: 19/08/2022 22:30
---


local function optimizeEmptySpace()
    print("--- optimizing empty space")
    for i=1,levelProps.sizeX do
        local lastBrickType = -1
        local lastJ = -1
        for j=levelProps.sizeY,1,-1 do -- traverse column BACKWARDS
            if lastBrickType == -1 and brickT[i][j][1] < 3 then
                lastBrickType = brickT[i][j][1]
            end
            if brickT[i][j][1] == lastBrickType and j>1 and (lastJ == -1 or lastJ - j < 255) then -- empty space with max height of 254
                if lastJ==-1 then
                    lastJ = j -- set END y of empty space
                end
            else -- always for j==1
                if lastJ~=-1 then
                    for k=j+1,lastJ do
                        --brickT[i][k][4]=lastJ-j
                        brickT[i][k][3]=lastJ-j -- h
                        brickT[i][k][5]=k-(j+1) -- cur Y sub index. 0-based
                    end
                    lastJ=-1
                    lastBrickType=-1
                end
            end

        end
    end
    -- todo horizontal direction too? then maybe we need purely column / row based drawing. not the "fast" approach
end

--- replace all non-cencrete bricks by 1x1 tiles, including empty space
--- in other words, keep only the type([1]), and set sizing values to 1,1,0,0
local function unOptimize()
    print("--- unOptimizing")
    for _, xTem in ipairs(brickT) do
        for y, yTem in ipairs(xTem) do
            if yTem[1] < 7 then
                xTem[y] = {yTem[1], 1, 1, 0, 0}
            end
        end
    end
end

local function condenseBricks()
    print("--- condensing bricks")
    --local brickTypeBU = selBrickType
    --xBU,yBU,curX,curY = curX,curY,1,1
    for color = 3,6 do
        editorStatusMsg = "Compacting "..blockNames[color].."s..."
        condenseSelection = {}
        --add all 1x1 of color
        for i = 1,levelProps.sizeX do
            for j = 1,levelProps.sizeY do
                local curBrick = brickT[i][j]
                if curBrick[1]==color and curBrick[2]==1 and curBrick[3]==1 then
                    table.insert(condenseSelection,{ i, j})
                end
                curBrick = nil
            end
        end
        clearSelection(condenseSelection)
        selBrickType = color
        fillSelection(nil, condenseSelection,true)
    end
end

function readBinaryBrickT(fileName)
    local packFormat = levelProps.packFormat
    print("Reading brickT from bin file, format:", packFormat)
    local packSize = love.data.getPackedSize(packFormat)
    local brickFile, file_error = love.filesystem.newFile( luaLevelDir..fileName..".bin", "r")
    assert(brickFile, file_error)
    assert(brickFile:isOpen(), "brickFile not open")
    local tile
    brickT = {}
    for x = 1, levelProps.sizeX do
        brickT[x] = {}
        for y = 1, levelProps.sizeY do
            local data = brickFile:read(packSize)
            tile = { love.data.unpack(packFormat, data) }
            table.remove(tile) -- remove the extra positional element returned by unpack
            brickT[x][y] = tile
        end
    end
end

function saveCompressedLevel(basePath)
    repairSpecials()
    condenseBricks()
    optimizeEmptySpace()

    -- FILE WRITE
    print("--- writing ".. basePath)
    local packFormat = writeCompressedBrickT(basePath .. ".bin", brickT)
    assert(packFormat, "No packFormat")
    levelProps.packFormat = packFormat
    writeLua(basePath .. ".lua", {
        levelProps = levelProps,
        specialT = specialT
    })

    unOptimize() -- also un-condenses
    editorStatusMsg = "Saved lua + compressed .bin file " .. basePath
end

function saveUnCompressedLevel(luaFilePath)
    writeLua(luaFilePath, {
        levelProps = levelProps,
        specialT = specialT,
        brickT = brickT
    })
    editorStatusMsg = "Saved uncompressed file " .. luaFilePath
end

function readLuaLevel(fileName)
    print("Reading Gravity Express format")
    local levelT = require("lua-levels/" .. fileName)
    specialT = levelT.specialT
    levelProps = levelT.levelProps
    brickT = levelT.brickT
    if not brickT then
        readBinaryBrickT(fileName)
    else
        print("brickT read from lua file")
    end
    unOptimize()
end

function convertLevel(fileName)
    print("Converting cgl + intermediate lua result from cgl reader")
    levelT = require("intermediates/" .. fileName .. "_intermediate")
    specialT = levelT.specialT
    levelProps = levelT.levelProps
    brickT = {}

    brickT = readCglBrickT(fileName)
    unOptimize()

    assert(levelProps.sizeX == #brickT, "Level width does not match beteen CGL and lua files!")
    assert(levelProps.sizeY == #brickT[1], "Level height does not match beteen CGL and lua files!")
    repairSpecials()

    saveCompressedLevel(luaLevelDir .. fileName)

    -- IMAGE OUT

    local canvas = love.graphics.newCanvas(levelProps.sizeX*tileSize,levelProps.sizeY*tileSize)
    love.graphics.setCanvas(canvas)
    --print("Frame-----")
    drawSpecials(camPos)
    drawBricks()
    --print("---- numDraws", numDraws)
    love.graphics.setCanvas()

    canvas:newImageData():encode("png",fileName .. ".png")
end
