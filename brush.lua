---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ninovanhooff.
--- DateTime: 11/06/2022 19:36
---

require("selection")

local random = love.math.random
local function noOp() end
local renderProgress = noOp

--- weighted bricksize, where larger bricks are more likely, returns 0-based size
local function randomBrickSize()
    local value = random()
    if value < 0.2 then
        return 0
    elseif value < 0.6 then
        return 1
    else
        return 2
    end
end

local function brushContains(k, l, brush)
    --printf("contains?",k,l)
    for i,item in pairs(brush) do
        if item[1]==k and item[2]==l then
            return true
        end
    end
    return false
end

function fillBrush(forceSize, brush, percentProgress)
    brush = brush or curBrush
    local fillCount = 0
    for i,item in ipairs(brush) do
        --item = brush[1]
        --printf("brusht",item[1],item[2])
        if brickT[curX+item[1]][curY+item[2]][1]==0 then -- if the first square is empty, double check?
            local tryWidth = forceSize or randomBrickSize()
            local tryHeight = forceSize or randomBrickSize()
            local maxW = tryWidth -- zero based!
            local maxH = tryHeight
            --printf("tries",maxW,maxH)
            for k=0,tryWidth do
                for l=0,tryHeight do
                    --[[if not BrushContains(item[1]+k,item[2]+l,brush) then
                        printf("failed brush bounds",k,l)
                        --constrK,constrL = BrushLimit(item[1]+k,item[2]+l)
                        maxW = math.fmin(maxW,k-1)--+constrK)
                        maxH = math.fmin(maxH,l-1)--+constrL)
                        --printf("new minima",maxW,maxH)
                        break]]
                    if not brushContains(item[1]+k,item[2]+l,brush) or brickT[curX+item[1]+k][curY+item[2]+l][1]~=0 then --curX+item[1]+k+1<levelProps.sizeX and curX+item[1]+k+1<levelProps.sizeY
                        --printf("fail: occupied",item[1],k,item[2],l)
                        if l==0 then
                            maxW = math.min(maxW,k-1)
                        else
                            maxH = math.min(maxH,l-1)
                        end
                        break
                    end
                end
            end
            if maxW<0 then maxW=0 end
            if maxH<0 then maxH=0 end
            --printf(item[1],item[2],"maxWH",maxW,maxH)
            for k=0,maxW do -- now fill it
                for l=0,maxH do
                    brickT[curX+item[1]+k][curY+item[2]+l] = {selBrickType,maxW+1,maxH+1,k,l} -- max is 1-based here!!
                    --	printf(selBrickType,maxW,maxH,k,l)
                    --if k==0 and l==0 then printf("fill",maxW,maxH) end
                end
            end
            fillCount = fillCount+1
            if math.fmod(fillCount,20)==19 then
                renderProgress(editorStatusMsg,i/#brush)
            end
            --printf("endfill")
        end
    end
end

function emptyBrush(brush)
    local selection = {}
    brush = brush or curBrush
    for _,item in pairs(brush) do
        table.insert(selection, {curX+item[1], curY + item[2]})
    end
    clearSelection(selection)
end

function SquareBrush(w)
    local brushT = {}
    for i = 0,w-1 do
        for j = 0,w-1 do
            table.insert(brushT,{i,j})
            printf("SquareBrush",i,j)
        end
    end
    BrushType = SquareBrush
    brushVerts = {{white,0,0,0},{white,w*8,0,0},{white,w*8,w*8,0},{white,0,w*8,50},{white,0,0,0}}
    brushSize = w
    return brushT
end

function CircleBrush(w) -- width
    local r = math.floor(w*0.5)
    local hw = r+0.5
    local brushT = {}
    brushVerts = {}
    for j=r,-r,-1 do
        local lr = math.floor(math.sqrt(r*r-j*j))
        --table.insert(brushVerts,{white,(r-lr)*8,(r-j)*8,0})

        table.insert(brushVerts,{white,(r+lr+1)*8,(r-j)*8,0}) -- right
        table.insert(brushVerts,{white,(r+lr+1)*8,(r-j+1)*8,0}) -- right
        table.insert(brushVerts,1,{white,(r-lr)*8,(r-j)*8,0}) -- left
        table.insert(brushVerts,1,{white,(r-lr)*8,(r-j+1)*8,0}) -- left
        printf("lr",lr)
        for i=r-lr,r+lr do
            table.insert(brushT,{i,r-j})
            printf("circbrushW",i,r-j)
        end
    end
    table.insert(brushVerts,brushVerts[1]) -- cap bottom
    BrushType = CircleBrush
    brushSize = w
    return brushT
end
